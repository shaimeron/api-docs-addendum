{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to TradeStation API - Addendum! For the OpenID Specification visit https://tradestation.github.io/api-docs . Purpose This document describes the resources that make up the official TradeStation API. If you have any problems or requests please contact support . Basics The TradeStation API is reachable at the base-url: https://api.tradestation.com/v2 Current Version The latest version is 20160101, but currently we are in transition, so by default all requests receive the 20101026 version for backwards compatibility. Always explicitly request this version by adding the APIVersion querystring parameter as shown below: https://api.tradestation.com/v2/data/quote/msft?APIVersion=20160101 Note: This will ensure your application will not be broken when we deprecate the 20101026 version in favor of 20160101 or newer versions. SIM vs LIVE We also offer a Simulator(SIM) API for \"Paper Trading\" that is identical to the Live API in all ways except it uses fake trading accounts seeded with fake money and orders are not actually executed - only simulated executions occur with instant \"fills\". To access the SIM environment, you must change your base-url to: https://sim-api.tradestation.com/v2 WARNING: TradeStation is not liable for mistakes made by applications that allow users to switch between SIM and Live environments. Why offer a Simulator? Transactional API calls such as Order Execution offers users or applications the ability to experiment within a Simulated trading system so that real accounts and money are not affected and trades are not actually executed. Other potential use-cases: - Learning how to use applications via Paper Trading. - Exploring TradeStation API behavior without financial ramifications - Testing apps and websites before making them Live to customers - Enabling users to \"Try-before-they-buy\" with apps that use the TradeStation API - Hosting trading competitions or games","title":"Home"},{"location":"#welcome-to-tradestation-api-addendum","text":"For the OpenID Specification visit https://tradestation.github.io/api-docs .","title":"Welcome to TradeStation API - Addendum!"},{"location":"#purpose","text":"This document describes the resources that make up the official TradeStation API. If you have any problems or requests please contact support .","title":"Purpose"},{"location":"#basics","text":"The TradeStation API is reachable at the base-url: https://api.tradestation.com/v2","title":"Basics"},{"location":"#current-version","text":"The latest version is 20160101, but currently we are in transition, so by default all requests receive the 20101026 version for backwards compatibility. Always explicitly request this version by adding the APIVersion querystring parameter as shown below: https://api.tradestation.com/v2/data/quote/msft?APIVersion=20160101 Note: This will ensure your application will not be broken when we deprecate the 20101026 version in favor of 20160101 or newer versions.","title":"Current Version"},{"location":"#sim-vs-live","text":"We also offer a Simulator(SIM) API for \"Paper Trading\" that is identical to the Live API in all ways except it uses fake trading accounts seeded with fake money and orders are not actually executed - only simulated executions occur with instant \"fills\". To access the SIM environment, you must change your base-url to: https://sim-api.tradestation.com/v2 WARNING: TradeStation is not liable for mistakes made by applications that allow users to switch between SIM and Live environments.","title":"SIM vs LIVE"},{"location":"#why-offer-a-simulator","text":"Transactional API calls such as Order Execution offers users or applications the ability to experiment within a Simulated trading system so that real accounts and money are not affected and trades are not actually executed. Other potential use-cases: - Learning how to use applications via Paper Trading. - Exploring TradeStation API behavior without financial ramifications - Testing apps and websites before making them Live to customers - Enabling users to \"Try-before-they-buy\" with apps that use the TradeStation API - Hosting trading competitions or games","title":"Why offer a Simulator?"},{"location":"about/","text":"About! The TradeStation API enables customers and partners to have direct access to TradeStation's real-time and historical market data, fast order-execution capabilities and access to your brokerage account, order & position information. We offer a REST API because of its flexibility and simplicity to enable traders to develop custom applications in any programming language that can speak HTTP (e.g. C#, Java, Python, Javascript, etc). Industry Leading Support. TradeStation API is backed by complete documentation and dedicated support for our clients: WebAPI Documentation Open Source Code Samples Private Forums Chat \u2013 Phone \u2013 E-Mail Is the TradeStation API right for you? To request access, please e-mail WebAPI@TradeStation.com","title":"About"},{"location":"about/#about","text":"The TradeStation API enables customers and partners to have direct access to TradeStation's real-time and historical market data, fast order-execution capabilities and access to your brokerage account, order & position information. We offer a REST API because of its flexibility and simplicity to enable traders to develop custom applications in any programming language that can speak HTTP (e.g. C#, Java, Python, Javascript, etc).","title":"About!"},{"location":"about/#industry-leading-support","text":"TradeStation API is backed by complete documentation and dedicated support for our clients: WebAPI Documentation Open Source Code Samples Private Forums Chat \u2013 Phone \u2013 E-Mail","title":"Industry Leading Support."},{"location":"about/#is-the-tradestation-api-right-for-you","text":"To request access, please e-mail WebAPI@TradeStation.com","title":"Is the TradeStation API right for you?"},{"location":"api-details/","text":"API Details MarketData Order-Execution Brokerage Accounts","title":"Exploring the API"},{"location":"api-details/#api-details","text":"MarketData Order-Execution Brokerage Accounts","title":"API Details"},{"location":"faq/","text":"Frequently Asked Questions","title":"FAQ"},{"location":"faq/#frequently-asked-questions","text":"","title":"Frequently Asked Questions"},{"location":"overview/","text":"HTTP Requests All API access is over HTTPS, and accessed from the https://api.tradestation.com. All data is sent and received as JSON, with some limited support for XML. Example Request: curl -i https://api.tradestation.com/v2/data/quote/msft?APIVersion=20160101 HTTP/1.1 200 OK Cache-Control: private Content-Length: 1545 Content-Type: application/default+json; charset=utf-8 Access-Control-Allow-Origin: * APIVersion: 20160101 Date: Wed, 30 Nov 2016 01:51:45 GMT [ ...json... ] Common Conventions Blank fields may either be included as null or omitted, so please support both. All timestamps are returned in Epoch time format unless stated otherwise. HTTP Streaming The TradeStation API offers HTTP Streaming responses for some specialized resources including intraday barcharts, quote changes, and quote snapshots. These streams conform to RFC2616 for HTTP/1.1 Streaming with some slight modifications. The HTTP streaming mechanism keeps a request open indefinitely. It never terminates the request or closes the connection, even after the server pushes data to the client. This mechanism significantly reduces the network latency because the client and the server do not need to open and close the connection. The basic life cycle of an application using HTTP streaming is as follows: The client makes an initial request and then waits for a response. The server defers the response to a poll request until an update is available, or until a particular status or timeout has occurred. Whenever an update is available, the server sends it back to the client as a part of the response. The data sent by the server does not terminate the request or the connection. The server returns to step 3. The HTTP streaming mechanism is based on the capability of the server to send several pieces of information in the same response, without terminating the request or the connection. Source: RFC6202, Page 7 . HTTP Streaming resources are identified under in this documentation as such, all other resources conform to the HTTP Request pattern instead. The HTTP Streaming response is returned with the following headers: ``` Transfer-Encoding: chunked Content-Type: application/vnd.tradestation.streams+json ``` Note: The Content-Length header is typically omitted since the response body size is unknown. Streams consist of a series of chunks that contain individual JSON objects to be parsed separately rather than as a whole response body. One unique thing about TradeStation's HTTP Streams is they also can terminate unlike a canonical HTTP/1.1 Stream. Streams terminate with a non-JSON string prefixed with one of the following: - `END` - `ERROR` In the case of ERROR , it will often be followed by an error message like: ERROR - A Timeout Occurred after waiting 15000ms In either case, the HTTP client must terminate the HTTP Stream and end the HTTP Request lifetime as a result of these messages. In the case of ERROR the client application may add a delay before re-requesting the HTTP Stream. How to handle HTTP Chunked Encoded Streams Healthy chunked-encoded streams emit variable length chunks that contain parsable JSON. For example: GET https://sim.api.tradestation.com/v2/stream/barchart/$DJI/1/Minute/12-26-2016/01-24-2017?access_token=\u00e2\u20ac\u00a6 HTTP/1.1 200 OK Date: Wed, 14 Jun 2017 01:17:36 GMT Content-Type: application/vnd.tradestation.streams+json Transfer-Encoding: chunked Connection: keep-alive Access-Control-Allow-Origin: * Cache-Control: private 114 {\"Close\":19956.09,\"DownTicks\":26,\"DownVolume\":940229,\"High\":19961.77,\"Low\":19943.46,\"Open\":19943.46,\"Status\":13,\"TimeStamp\":\"\\/Date(1482849060000)\\/\",\"TotalTicks\":59,\"TotalVolume\":3982533,\"UnchangedTicks\":0,\"UnchangedVolume\":0,\"UpTicks\":33,\"UpVolume\":3042304,\"OpenInterest\":0} 112 {\"Close\":19950.82,\"DownTicks\":32,\"DownVolume\":440577,\"High\":19959.15,\"Low\":19947.34,\"Open\":19955.64,\"Status\":13,\"TimeStamp\":\"\\/Date(1482849120000)\\/\",\"TotalTicks\":60,\"TotalVolume\":761274,\"UnchangedTicks\":0,\"UnchangedVolume\":0,\"UpTicks\":28,\"UpVolume\":320697,\"OpenInterest\":0} END Typically this will stream forever, unless a network interruption or service disruption occurs. It is up to the client to properly handle stream lifetime and connection closing. How to parse JSON chunks In order to process these chunks, API consumers should first read the response buffer, then de-chunk the plain-text strings, and finally identify new JSON objects by applying tokenizing techniques to the resulting text stream using either a streaming JSON parser, Regex, a lexer/parser, or brute-force string indexing logic. A simple but effective technique is after de-chunking to simply parse based upon the \\n (newline character) delimiter written to the end of each JSON object. However, a more robust solution is less likely to break later. Variable Length JSON Chunking As a developer, be careful with how you parse HTTP Streams, because the API\u00e2\u20ac\u2122s or intermediate proxies may chunk JSON objects many different ways. Using HTTP streaming, several application messages can be sent within a single HTTP response. The separation of the response stream into application messages needs to be performed at the application level and not at the HTTP level. In particular, it is not possible to use the HTTP chunks as application message delimiters, since intermediate proxies might \u00e2\u20ac\u0153re-chunk\u00e2\u20ac\u009d the message stream (for example, by combining different chunks into a longer one). This issue does not affect the HTTP long polling technique, which provides a canonical framing technique: each application message can be sent in a different HTTP response. Source: RFC6202, Section 3.2 Translation: Be prepared for JSON objects that span chunks. You may see chunks with varying numbers of JSON objects, including: \"exactly 1\" JSON object per chunk \u00e2\u20ac\u0153at least 1\u00e2\u20ac\u009d JSON object per chunk 1 JSON object split across 2 or more chunks Example of 2 JSON objects in 1 chunk: GET https://sim.api.tradestation.com/v2/stream/barchart/$DJI/1/Minute/12-26-2016/01-24-2017?access_token=\u00e2\u20ac\u00a6 HTTP/1.1 200 OK Date: Wed, 14 Jun 2017 01:17:36 GMT Content-Type: application/vnd.tradestation.streams+json Transfer-Encoding: chunked Connection: keep-alive Access-Control-Allow-Origin: * Cache-Control: private 22d {\"Close\":19956.09,\"DownTicks\":26,\"DownVolume\":940229,\"High\":19961.77,\"Low\":19943.46,\"Open\":19943.46,\"Status\":13,\"TimeStamp\":\"\\/Date(1482849060000)\\/\",\"TotalTicks\":59,\"TotalVolume\":3982533,\"UnchangedTicks\":0,\"UnchangedVolume\":0,\"UpTicks\":33,\"UpVolume\":3042304,\"OpenInterest\":0} {\"Close\":19950.82,\"DownTicks\":32,\"DownVolume\":440577,\"High\":19959.15,\"Low\":19947.34,\"Open\":19955.64,\"Status\":13,\"TimeStamp\":\"\\/Date(1482849120000)\\/\",\"TotalTicks\":60,\"TotalVolume\":761274,\"UnchangedTicks\":0,\"UnchangedVolume\":0,\"UpTicks\":28,\"UpVolume\":320697,\"OpenInterest\":0} END Example of 1 JSON objects split across 2 chunks: GET https://sim.api.tradestation.com/v2/stream/barchart/$DJI/1/Minute/12-26-2016/01-24-2017?access_token=\u00e2\u20ac\u00a6 HTTP/1.1 200 OK Date: Wed, 14 Jun 2017 01:17:36 GMT Content-Type: application/vnd.tradestation.streams+json Transfer-Encoding: chunked Connection: keep-alive Access-Control-Allow-Origin: * Cache-Control: private 40 {\"Close\":71.65,\"DownTicks\":45,\"DownVolume\":5406,\"High\":71.67,\"Lo C2 w\":71.65,\"Open\":71.66,\"Status\":13,\"TimeStamp\":\"\\/Date(1497016260000)\\/\",\"TotalTicks\":77,\"TotalVolume\":17270,\"UnchangedTicks\":0,\"UnchangedVolume\":0,\"UpTicks\":32,\"UpVolume\":11864,\"OpenInterest\":0} END This is allowed by the HTTP/1.1 specification, but can be confusing or lead to bugs in client applications if you try to depend parsing JSON along the HTTP chunk-boundaries because even if it works during testing, later if users connect from a different network, it may change the chunking behavior. For example, if you are at a coffee shop with wifi which employs an HTTP Proxy, then it may buffer the stream and change the chunking boundary from 1 JSON object per chunk, to splitting each JSON object across 2 or 3. In fact, the HTTP/1.1 spec clearly advises developers of proxies to always \u00e2\u20ac\u0153re-chunk\u00e2\u20ac\u009d HTTP Streams, so this is almost a guarantee to happen in the wild. HTTP Streaming API consumers should be prepared to support all variations.","title":"Overview"},{"location":"overview/#http-requests","text":"All API access is over HTTPS, and accessed from the https://api.tradestation.com. All data is sent and received as JSON, with some limited support for XML. Example Request: curl -i https://api.tradestation.com/v2/data/quote/msft?APIVersion=20160101 HTTP/1.1 200 OK Cache-Control: private Content-Length: 1545 Content-Type: application/default+json; charset=utf-8 Access-Control-Allow-Origin: * APIVersion: 20160101 Date: Wed, 30 Nov 2016 01:51:45 GMT [ ...json... ]","title":"HTTP Requests"},{"location":"overview/#common-conventions","text":"Blank fields may either be included as null or omitted, so please support both. All timestamps are returned in Epoch time format unless stated otherwise.","title":"Common Conventions"},{"location":"overview/#http-streaming","text":"The TradeStation API offers HTTP Streaming responses for some specialized resources including intraday barcharts, quote changes, and quote snapshots. These streams conform to RFC2616 for HTTP/1.1 Streaming with some slight modifications. The HTTP streaming mechanism keeps a request open indefinitely. It never terminates the request or closes the connection, even after the server pushes data to the client. This mechanism significantly reduces the network latency because the client and the server do not need to open and close the connection. The basic life cycle of an application using HTTP streaming is as follows: The client makes an initial request and then waits for a response. The server defers the response to a poll request until an update is available, or until a particular status or timeout has occurred. Whenever an update is available, the server sends it back to the client as a part of the response. The data sent by the server does not terminate the request or the connection. The server returns to step 3. The HTTP streaming mechanism is based on the capability of the server to send several pieces of information in the same response, without terminating the request or the connection. Source: RFC6202, Page 7 . HTTP Streaming resources are identified under in this documentation as such, all other resources conform to the HTTP Request pattern instead. The HTTP Streaming response is returned with the following headers: ``` Transfer-Encoding: chunked Content-Type: application/vnd.tradestation.streams+json ``` Note: The Content-Length header is typically omitted since the response body size is unknown. Streams consist of a series of chunks that contain individual JSON objects to be parsed separately rather than as a whole response body. One unique thing about TradeStation's HTTP Streams is they also can terminate unlike a canonical HTTP/1.1 Stream. Streams terminate with a non-JSON string prefixed with one of the following: - `END` - `ERROR` In the case of ERROR , it will often be followed by an error message like: ERROR - A Timeout Occurred after waiting 15000ms In either case, the HTTP client must terminate the HTTP Stream and end the HTTP Request lifetime as a result of these messages. In the case of ERROR the client application may add a delay before re-requesting the HTTP Stream.","title":"HTTP Streaming"},{"location":"overview/#how-to-handle-http-chunked-encoded-streams","text":"Healthy chunked-encoded streams emit variable length chunks that contain parsable JSON. For example: GET https://sim.api.tradestation.com/v2/stream/barchart/$DJI/1/Minute/12-26-2016/01-24-2017?access_token=\u00e2\u20ac\u00a6 HTTP/1.1 200 OK Date: Wed, 14 Jun 2017 01:17:36 GMT Content-Type: application/vnd.tradestation.streams+json Transfer-Encoding: chunked Connection: keep-alive Access-Control-Allow-Origin: * Cache-Control: private 114 {\"Close\":19956.09,\"DownTicks\":26,\"DownVolume\":940229,\"High\":19961.77,\"Low\":19943.46,\"Open\":19943.46,\"Status\":13,\"TimeStamp\":\"\\/Date(1482849060000)\\/\",\"TotalTicks\":59,\"TotalVolume\":3982533,\"UnchangedTicks\":0,\"UnchangedVolume\":0,\"UpTicks\":33,\"UpVolume\":3042304,\"OpenInterest\":0} 112 {\"Close\":19950.82,\"DownTicks\":32,\"DownVolume\":440577,\"High\":19959.15,\"Low\":19947.34,\"Open\":19955.64,\"Status\":13,\"TimeStamp\":\"\\/Date(1482849120000)\\/\",\"TotalTicks\":60,\"TotalVolume\":761274,\"UnchangedTicks\":0,\"UnchangedVolume\":0,\"UpTicks\":28,\"UpVolume\":320697,\"OpenInterest\":0} END Typically this will stream forever, unless a network interruption or service disruption occurs. It is up to the client to properly handle stream lifetime and connection closing.","title":"How to handle HTTP Chunked Encoded Streams"},{"location":"overview/#how-to-parse-json-chunks","text":"In order to process these chunks, API consumers should first read the response buffer, then de-chunk the plain-text strings, and finally identify new JSON objects by applying tokenizing techniques to the resulting text stream using either a streaming JSON parser, Regex, a lexer/parser, or brute-force string indexing logic. A simple but effective technique is after de-chunking to simply parse based upon the \\n (newline character) delimiter written to the end of each JSON object. However, a more robust solution is less likely to break later.","title":"How to parse JSON chunks"},{"location":"overview/#variable-length-json-chunking","text":"As a developer, be careful with how you parse HTTP Streams, because the API\u00e2\u20ac\u2122s or intermediate proxies may chunk JSON objects many different ways. Using HTTP streaming, several application messages can be sent within a single HTTP response. The separation of the response stream into application messages needs to be performed at the application level and not at the HTTP level. In particular, it is not possible to use the HTTP chunks as application message delimiters, since intermediate proxies might \u00e2\u20ac\u0153re-chunk\u00e2\u20ac\u009d the message stream (for example, by combining different chunks into a longer one). This issue does not affect the HTTP long polling technique, which provides a canonical framing technique: each application message can be sent in a different HTTP response. Source: RFC6202, Section 3.2 Translation: Be prepared for JSON objects that span chunks. You may see chunks with varying numbers of JSON objects, including: \"exactly 1\" JSON object per chunk \u00e2\u20ac\u0153at least 1\u00e2\u20ac\u009d JSON object per chunk 1 JSON object split across 2 or more chunks Example of 2 JSON objects in 1 chunk: GET https://sim.api.tradestation.com/v2/stream/barchart/$DJI/1/Minute/12-26-2016/01-24-2017?access_token=\u00e2\u20ac\u00a6 HTTP/1.1 200 OK Date: Wed, 14 Jun 2017 01:17:36 GMT Content-Type: application/vnd.tradestation.streams+json Transfer-Encoding: chunked Connection: keep-alive Access-Control-Allow-Origin: * Cache-Control: private 22d {\"Close\":19956.09,\"DownTicks\":26,\"DownVolume\":940229,\"High\":19961.77,\"Low\":19943.46,\"Open\":19943.46,\"Status\":13,\"TimeStamp\":\"\\/Date(1482849060000)\\/\",\"TotalTicks\":59,\"TotalVolume\":3982533,\"UnchangedTicks\":0,\"UnchangedVolume\":0,\"UpTicks\":33,\"UpVolume\":3042304,\"OpenInterest\":0} {\"Close\":19950.82,\"DownTicks\":32,\"DownVolume\":440577,\"High\":19959.15,\"Low\":19947.34,\"Open\":19955.64,\"Status\":13,\"TimeStamp\":\"\\/Date(1482849120000)\\/\",\"TotalTicks\":60,\"TotalVolume\":761274,\"UnchangedTicks\":0,\"UnchangedVolume\":0,\"UpTicks\":28,\"UpVolume\":320697,\"OpenInterest\":0} END Example of 1 JSON objects split across 2 chunks: GET https://sim.api.tradestation.com/v2/stream/barchart/$DJI/1/Minute/12-26-2016/01-24-2017?access_token=\u00e2\u20ac\u00a6 HTTP/1.1 200 OK Date: Wed, 14 Jun 2017 01:17:36 GMT Content-Type: application/vnd.tradestation.streams+json Transfer-Encoding: chunked Connection: keep-alive Access-Control-Allow-Origin: * Cache-Control: private 40 {\"Close\":71.65,\"DownTicks\":45,\"DownVolume\":5406,\"High\":71.67,\"Lo C2 w\":71.65,\"Open\":71.66,\"Status\":13,\"TimeStamp\":\"\\/Date(1497016260000)\\/\",\"TotalTicks\":77,\"TotalVolume\":17270,\"UnchangedTicks\":0,\"UnchangedVolume\":0,\"UpTicks\":32,\"UpVolume\":11864,\"OpenInterest\":0} END This is allowed by the HTTP/1.1 specification, but can be confusing or lead to bugs in client applications if you try to depend parsing JSON along the HTTP chunk-boundaries because even if it works during testing, later if users connect from a different network, it may change the chunking behavior. For example, if you are at a coffee shop with wifi which employs an HTTP Proxy, then it may buffer the stream and change the chunking boundary from 1 JSON object per chunk, to splitting each JSON object across 2 or 3. In fact, the HTTP/1.1 spec clearly advises developers of proxies to always \u00e2\u20ac\u0153re-chunk\u00e2\u20ac\u009d HTTP Streams, so this is almost a guarantee to happen in the wild. HTTP Streaming API consumers should be prepared to support all variations.","title":"Variable Length JSON Chunking"},{"location":"brokerage/","text":"Brokerage API Return to Exploring the API","title":"Brokerage API"},{"location":"brokerage/#brokerage-api","text":"Return to Exploring the API","title":"Brokerage API"},{"location":"brokerage/accounts/","text":"","title":"Accounts"},{"location":"brokerage/balances/","text":"","title":"Balances"},{"location":"brokerage/orders/","text":"","title":"Orders"},{"location":"brokerage/positions/","text":"","title":"Positions"},{"location":"getting-started/","text":"Getting Started How to Login Creating a Console App ( python | c# | javascript | golang ) Creating a simple Web App ( python ) Creating a React Web App","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"How to Login Creating a Console App ( python | c# | javascript | golang ) Creating a simple Web App ( python ) Creating a React Web App","title":"Getting Started"},{"location":"getting-started/authentication/","text":"How to Login to TradeStation API Return to Getting Started","title":"How to Login to TradeStation API"},{"location":"getting-started/authentication/#how-to-login-to-tradestation-api","text":"Return to Getting Started","title":"How to Login to TradeStation API"},{"location":"getting-started/console-app/","text":"Creating a Console Application Language Example Description python Basic Console App to get a Quote javascript Basic Console App to get a Quote C# Basic Console App to get a Quote golang Basic Console App to get a Quote Return to Getting Started","title":"Creating a Console Application"},{"location":"getting-started/console-app/#creating-a-console-application","text":"Language Example Description python Basic Console App to get a Quote javascript Basic Console App to get a Quote C# Basic Console App to get a Quote golang Basic Console App to get a Quote Return to Getting Started","title":"Creating a Console Application"},{"location":"getting-started/console-app/csharp/","text":"C# Console App - Example Return to Console Apps Return to Getting Started","title":"C# Console App - Example"},{"location":"getting-started/console-app/csharp/#c-console-app-example","text":"Return to Console Apps Return to Getting Started","title":"C# Console App - Example"},{"location":"getting-started/console-app/golang/","text":"Golang Console App - Example Return to Console Apps Return to Getting Started","title":"Golang Console App - Example"},{"location":"getting-started/console-app/golang/#golang-console-app-example","text":"Return to Console Apps Return to Getting Started","title":"Golang Console App - Example"},{"location":"getting-started/console-app/javascript/","text":"Javascript Console App - Example Return to Console Apps Return to Getting Started","title":"Javascript Console App - Example"},{"location":"getting-started/console-app/javascript/#javascript-console-app-example","text":"Return to Console Apps Return to Getting Started","title":"Javascript Console App - Example"},{"location":"getting-started/console-app/python/","text":"Python Console App - Example Return to Console Apps Return to Getting Started","title":"Python Console App - Example"},{"location":"getting-started/console-app/python/#python-console-app-example","text":"Return to Console Apps Return to Getting Started","title":"Python Console App - Example"},{"location":"getting-started/react-app/","text":"Creating a React Web Application Return to Getting Started","title":"Creating a React Web Application"},{"location":"getting-started/react-app/#creating-a-react-web-application","text":"Return to Getting Started","title":"Creating a React Web Application"},{"location":"getting-started/web-app/","text":"Creating a simple Web Application Language Example Description Python Simple 1-Page Tester This is a Test Page to allow you to login & try various TradeStation API's Return to Getting Started","title":"Creating a simple Web Application"},{"location":"getting-started/web-app/#creating-a-simple-web-application","text":"Language Example Description Python Simple 1-Page Tester This is a Test Page to allow you to login & try various TradeStation API's Return to Getting Started","title":"Creating a simple Web Application"},{"location":"getting-started/web-app/python/","text":"","title":"Python"},{"location":"marketdata/","text":"Market Data API Level1 Quotes Level1 Quote Changes (streaming) Level1 Quote Snapshots (streaming) Barcharts (streaming) Tickbars (streaming) Return to Exploring the API","title":"Market Data API"},{"location":"marketdata/#market-data-api","text":"Level1 Quotes Level1 Quote Changes (streaming) Level1 Quote Snapshots (streaming) Barcharts (streaming) Tickbars (streaming) Return to Exploring the API","title":"Market Data API"},{"location":"marketdata/barcharts/","text":"BarCharts Return to MarketData Return to Exploring the API","title":"BarCharts"},{"location":"marketdata/barcharts/#barcharts","text":"Return to MarketData Return to Exploring the API","title":"BarCharts"},{"location":"marketdata/quote-changes/","text":"MarketData Quote Changes Return to MarketData Return to Exploring the API","title":"MarketData Quote Changes"},{"location":"marketdata/quote-changes/#marketdata-quote-changes","text":"Return to MarketData Return to Exploring the API","title":"MarketData Quote Changes"},{"location":"marketdata/quote-snapshots/","text":"MarketData Quote Snapshots Return to MarketData Return to Exploring the API","title":"MarketData Quote Snapshots"},{"location":"marketdata/quote-snapshots/#marketdata-quote-snapshots","text":"Return to MarketData Return to Exploring the API","title":"MarketData Quote Snapshots"},{"location":"marketdata/quotes/","text":"MarketData Quotes Return to MarketData Return to Exploring the API","title":"MarketData Quotes"},{"location":"marketdata/quotes/#marketdata-quotes","text":"Return to MarketData Return to Exploring the API","title":"MarketData Quotes"},{"location":"marketdata/symbol-search/","text":"MarketData Symbol Search Return to MarketData Return to Exploring the API","title":"MarketData Symbol Search"},{"location":"marketdata/symbol-search/#marketdata-symbol-search","text":"Return to MarketData Return to Exploring the API","title":"MarketData Symbol Search"},{"location":"marketdata/symbol-suggest/","text":"MarketData Symbol Suggest Return to MarketData Return to Exploring the API","title":"MarketData Symbol Suggest"},{"location":"marketdata/symbol-suggest/#marketdata-symbol-suggest","text":"Return to MarketData Return to Exploring the API","title":"MarketData Symbol Suggest"},{"location":"marketdata/tickbars/","text":"Tickbars Return to MarketData Return to Exploring the API","title":"Tickbars"},{"location":"marketdata/tickbars/#tickbars","text":"Return to MarketData Return to Exploring the API","title":"Tickbars"},{"location":"order-execution/","text":"Order Execution API Return to Exploring the API","title":"Order Execution API"},{"location":"order-execution/#order-execution-api","text":"Return to Exploring the API","title":"Order Execution API"},{"location":"troubleshooting/","text":"Troubleshooting Rate Limiting Supported SSL/TLS Versions","title":"Troubleshooting"},{"location":"troubleshooting/#troubleshooting","text":"Rate Limiting Supported SSL/TLS Versions","title":"Troubleshooting"},{"location":"troubleshooting/rate-limiting/","text":"Rate Limiting The TradeStation API Rate Limits on the number of requests a given user & client can make to the API in order to ensure fairness between users and prevent abuse to our network. Each API Key is allocated quota settings upon creation. These settings are applied on a per-user basis. If the quota is exceeded, an HTTP response of 403 Quota Exceeded will be returned. Quotas are reset on a 5-minute interval based on when the user issued the first request. Resource Categories The rate limit applies to the following resource-categories: Resource-Category Quota Interval Accounts 250 5-minute Order Details 250 5-minute Balances 250 5-minute Positions 250 5-minute Data Quotes 250 5-minute Quote Change Stream 500 5-minute Quote Snapshot Stream 500 5-minute Barchart Stream 500 5-minute TickBar Stream 500 5-minute Intervals Quotas have \"Windows\" that last for a limited time interval (generally 5-minutes). Once the user has exceeded the maximum request count, all future requests will fail with a 403 error until the interval expires. Rate Limit intervals do not slide based upon the number of requests, they are fixed at a point in time starting from the very first request for that category of resource. After the interval expires, the cycle will start over at zero and the user can make more requests. Example A A user logs into the TradeStation WebAPI with your application and issues a request to /v2/EliteTrader/accounts . As a result, the request quota is incremented by one for the Accounts resource-category. The user then issues 250 more requests immediately to /v2/EliteTrader/accounts . The last request fails with 403 Quota Exceeded . All subsequent requests continue to fail until the 5-minute interval expires from the time of the very first request. Example B A user logs into the TradeStation WebAPI with your application and issues a request to /v2/data/quote/IBM,NFLX,MSFT,AMZN,AAPL . As a result, the request quota is incremented by one for the Data Quotes resource-category. The user then immediately issues the same request 250 more times. The last request fails with 403 Quota Exceeded . All subsequent requests continue to fail until the 5-minute interval expires from the time of the first request. Example Throttled Request GET https://api.tradestation.com/v2/data/quotes/IBM,NFLX,MSFT,AMZN,AAPL HTTP/1.1 Host: api.tradestation.com Authorization: bearer eE45VkdQSnlBcmI0Q2RqTi82SFdMSVE0SXMyOFo5Z3dzVzdzdk Accept: application/json Example Failed Response HTTP/1.1 403 Quota Exceeded Content-Length: 15 Server: Microsoft-IIS/7.5 X-AspNet-Version: 4.0.30319 Date: Tue, 06 Dec 2011 20:50:32 GMT <html><body>Quota Exceeded</body></html> Return to Troubleshooting","title":"Rate limiting"},{"location":"troubleshooting/rate-limiting/#rate-limiting","text":"The TradeStation API Rate Limits on the number of requests a given user & client can make to the API in order to ensure fairness between users and prevent abuse to our network. Each API Key is allocated quota settings upon creation. These settings are applied on a per-user basis. If the quota is exceeded, an HTTP response of 403 Quota Exceeded will be returned. Quotas are reset on a 5-minute interval based on when the user issued the first request.","title":"Rate Limiting"},{"location":"troubleshooting/rate-limiting/#resource-categories","text":"The rate limit applies to the following resource-categories: Resource-Category Quota Interval Accounts 250 5-minute Order Details 250 5-minute Balances 250 5-minute Positions 250 5-minute Data Quotes 250 5-minute Quote Change Stream 500 5-minute Quote Snapshot Stream 500 5-minute Barchart Stream 500 5-minute TickBar Stream 500 5-minute","title":"Resource Categories"},{"location":"troubleshooting/rate-limiting/#intervals","text":"Quotas have \"Windows\" that last for a limited time interval (generally 5-minutes). Once the user has exceeded the maximum request count, all future requests will fail with a 403 error until the interval expires. Rate Limit intervals do not slide based upon the number of requests, they are fixed at a point in time starting from the very first request for that category of resource. After the interval expires, the cycle will start over at zero and the user can make more requests.","title":"Intervals"},{"location":"troubleshooting/rate-limiting/#example-a","text":"A user logs into the TradeStation WebAPI with your application and issues a request to /v2/EliteTrader/accounts . As a result, the request quota is incremented by one for the Accounts resource-category. The user then issues 250 more requests immediately to /v2/EliteTrader/accounts . The last request fails with 403 Quota Exceeded . All subsequent requests continue to fail until the 5-minute interval expires from the time of the very first request.","title":"Example A"},{"location":"troubleshooting/rate-limiting/#example-b","text":"A user logs into the TradeStation WebAPI with your application and issues a request to /v2/data/quote/IBM,NFLX,MSFT,AMZN,AAPL . As a result, the request quota is incremented by one for the Data Quotes resource-category. The user then immediately issues the same request 250 more times. The last request fails with 403 Quota Exceeded . All subsequent requests continue to fail until the 5-minute interval expires from the time of the first request. Example Throttled Request GET https://api.tradestation.com/v2/data/quotes/IBM,NFLX,MSFT,AMZN,AAPL HTTP/1.1 Host: api.tradestation.com Authorization: bearer eE45VkdQSnlBcmI0Q2RqTi82SFdMSVE0SXMyOFo5Z3dzVzdzdk Accept: application/json Example Failed Response HTTP/1.1 403 Quota Exceeded Content-Length: 15 Server: Microsoft-IIS/7.5 X-AspNet-Version: 4.0.30319 Date: Tue, 06 Dec 2011 20:50:32 GMT <html><body>Quota Exceeded</body></html> Return to Troubleshooting","title":"Example B"},{"location":"troubleshooting/ssl-tls-versions/","text":"Supported SSL/TLS Versions We take security seriously with the TradeStation API and the first line of defense is utilizing HTTPS for all requests. Security is a constant battle since old SSL/TLS versions get broken every day and new security measures emerge. From time to time, we will disable old versions of SSL/TLS and force everyone to update to the latest versions. This will be done with care to avoid breaking your applications, but also with a sense of urgency to ensure you can conduct your trading in a safe and secure manner. Below is a table of the supported SSL/TLS versions & cipher suites: Protocols Supported? Dates SSL v1-v3 No TLSv1 No TLSv1.1 Yes Expiring in 2020 TLSv1.2 Yes TLSv1.3 No Coming in 2020 TLS Ciphers Supported? Dates ECDHE-ECDSA-AES128-GCM-SHA256 Yes ECDHE-RSA-AES128-GCM-SHA256 Yes ECDHE-ECDSA-AES128-SHA256 Yes ECDHE-RSA-AES128-SHA256 Yes ECDHE-ECDSA-AES128-SHA Yes ECDHE-RSA-AES128-SHA Yes ECDHE-ECDSA-AES256-GCM-SHA384 Yes ECDHE-RSA-AES256-GCM-SHA384 Yes ECDHE-ECDSA-AES256-SHA384 Yes ECDHE-RSA-AES256-SHA384 Yes ECDHE-RSA-AES256-SHA Yes ECDHE-ECDSA-AES256-SHA Yes AES128-GCM-SHA256 Yes AES128-SHA256 Yes AES128-SHA Yes AES256-GCM-SHA384 Yes AES256-SHA256 Yes AES256-SHA Yes DES-CBC3-SHA No NOTE: Omitted cipher suites are not supported Return to Troubleshooting","title":"Supported SSL/TLS Versions"},{"location":"troubleshooting/ssl-tls-versions/#supported-ssltls-versions","text":"We take security seriously with the TradeStation API and the first line of defense is utilizing HTTPS for all requests. Security is a constant battle since old SSL/TLS versions get broken every day and new security measures emerge. From time to time, we will disable old versions of SSL/TLS and force everyone to update to the latest versions. This will be done with care to avoid breaking your applications, but also with a sense of urgency to ensure you can conduct your trading in a safe and secure manner. Below is a table of the supported SSL/TLS versions & cipher suites: Protocols Supported? Dates SSL v1-v3 No TLSv1 No TLSv1.1 Yes Expiring in 2020 TLSv1.2 Yes TLSv1.3 No Coming in 2020 TLS Ciphers Supported? Dates ECDHE-ECDSA-AES128-GCM-SHA256 Yes ECDHE-RSA-AES128-GCM-SHA256 Yes ECDHE-ECDSA-AES128-SHA256 Yes ECDHE-RSA-AES128-SHA256 Yes ECDHE-ECDSA-AES128-SHA Yes ECDHE-RSA-AES128-SHA Yes ECDHE-ECDSA-AES256-GCM-SHA384 Yes ECDHE-RSA-AES256-GCM-SHA384 Yes ECDHE-ECDSA-AES256-SHA384 Yes ECDHE-RSA-AES256-SHA384 Yes ECDHE-RSA-AES256-SHA Yes ECDHE-ECDSA-AES256-SHA Yes AES128-GCM-SHA256 Yes AES128-SHA256 Yes AES128-SHA Yes AES256-GCM-SHA384 Yes AES256-SHA256 Yes AES256-SHA Yes DES-CBC3-SHA No NOTE: Omitted cipher suites are not supported Return to Troubleshooting","title":"Supported SSL/TLS Versions"}]}